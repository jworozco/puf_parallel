
//import puf_pkg::*;
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module pp_top(


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input                           CLOCK_50,

//////////// LED //////////
output logic       [7:0]        LED,

//////////// KEY //////////
input              [1:0]        KEY,

//////////// SW //////////
input              [3:0]        SW

/* //////////// SDRAM //////////
output logic       [12:0]       DRAM_ADDR,
output logic       [1:0]        DRAM_BA,
output logic                    DRAM_CAS_N,
output logic                    DRAM_CKE,
output logic                    DRAM_CLK,
output logic                    DRAM_CS_N,
inout             [15:0]        DRAM_DQ,
output logic       [1:0]        DRAM_DQM,
output logic                    DRAM_RAS_N,
output logic                    DRAM_WE_N,

//////////// EPCS //////////
output logic                    EPCS_ASDO,
input                           EPCS_DATA0,
output logic                    EPCS_DCLK,
output logic                    EPCS_NCSO,

//////////// Accelerometer and EEPROM //////////
output logic                    G_SENSOR_CS_N,
input                           G_SENSOR_INT,
output logic                    I2C_SCLK,
inout                           I2C_SDAT,

//////////// ADC //////////
output logic                    ADC_CS_N,
output logic                    ADC_SADDR,
output logic                    ADC_SCLK,
input                           ADC_SDAT,

//////////// 2x13 GPIO Header //////////
inout             [12:0]        GPIO_2,
input              [2:0]        GPIO_2_IN,

//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
inout             [33:0]        GPIO_0,
input              [1:0]        GPIO_0_IN,

//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
inout             [33:0]        GPIO_1,
input              [1:0]        GPIO_1_IN
 */
);


//=======================================================
//  REG/WIRE declarations
//=======================================================

// Inputs
wire [31:0] enables1;
wire [31:0] enables2;
wire fsm_rst; // reset for FSM
wire fsm_restart; // restart for FSM
wire puf1_rst; // reset for PUF 1
wire puf2_rst; // reset for PUF 2

// Outputs
wire [7:0] response1;
wire [7:0] response2;
wire [7:0] done1;
wire [7:0] done2;
wire all_done1;
wire all_done2;

wire [7:0] puf1_counter;
wire [7:0] puf2_counter;

//=======================================================
//  Structural coding
//=======================================================

//Instantiate the PUF module

 puf_parallel parallel_scheme1 (
        .enable (enables1),
        .challenge (puf1_counter),
        .out (response1),
        .done (done1),
        .clock (CLOCK_50),
        .reset (puf1_rst),
        .all_done (all_done1)
        );

puf_parallel parallel_scheme2 (
        .enable (enables2),
        .challenge (puf2_counter),
        .out (response2),
        .done (done2),
        .clock (CLOCK_50),
        .reset (puf2_rst),
        .all_done (all_done2)
        );

//typedef enum logic [1:0] { START, PUF1, PUF2, HALT } state_t;
state_t ps;  //present state

fsm puf_fsm (
    .clk (CLOCK_50),
    .fsm_rst(fsm_rst),
    .fsm_restart(fsm_restart),
    .KEY(key_sync),
    .ps(ps),
    .puf1_counter(puf1_counter),
    .puf2_counter(puf2_counter)
    );

// Use SW as PUF reset and restart
assign fsm_rst = SW[0]; //reset the FSM is async
logic SW1_dsync;        //synchronized version of SW1
assign fsm_restart = SW1_dsync; //restart the FSM needs to be sync first


// Assign the LED to show the current SC response
assign LED = (ps == PUF1) ? response1 :
             (ps == PUF2) ? response2 :
             '0;

// generate the PUF reset after each challenge
assign puf1_rst = (ps != PUF1);
assign puf2_rst = (ps != PUF2);

// generate the enables
assign enables1 = {32{(ps == PUF1)}}; //enables are set only in PUF1
assign enables2 = {32{(ps == PUF2)}}; //enables are set only in PUF2

//add synchronization for the KEYS
logic [1:0] key_sync;

dsync key_dsync0 (
    .dsync (key_sync[0]),
    .d (KEY[0]),
    .clk (CLOCK_50),
    .reset (fsm_rst)
    );

dsync key_dsync1 (
    .dsync (key_sync[1]),
    .d (KEY[1]),
    .clk (CLOCK_50),
    .reset (fsm_rst)
    );

dsync sw_dsync1 (
    .dsync (SW1_dsync),
    .d (SW[1]),
    .clk (CLOCK_50),
    .reset (fsm_rst)
    );


endmodule


